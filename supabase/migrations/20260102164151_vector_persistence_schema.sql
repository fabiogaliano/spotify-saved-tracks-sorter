-- ============================================================================ -- Vector Persistence Schema -- Phase 2 of Model Optimization Implementation -- ============================================================================  -- 1. Enable pgvector extension CREATE EXTENSION IF NOT EXISTS vector WITH SCHEMA extensions;  -- ============================================================================ -- 2. Create track_embeddings table -- ============================================================================ -- Stores track embeddings with versioning for model swaps CREATE TABLE IF NOT EXISTS public.track_embeddings (     id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,     track_id INTEGER NOT NULL REFERENCES public.tracks(id) ON DELETE CASCADE,      -- Embedding identification     embedding_kind TEXT NOT NULL,     model_name TEXT NOT NULL,     model_version TEXT NOT NULL,     dims INTEGER NOT NULL,      -- Content hash for cache invalidation     content_hash TEXT NOT NULL,      -- The actual embedding vector (1024 dims for E5-large)     embedding vector(1024) NOT NULL,      -- Metadata     created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),     updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW() );  -- Unique constraint for idempotent upserts CREATE UNIQUE INDEX IF NOT EXISTS track_embeddings_unique_idx ON public.track_embeddings(track_id, embedding_kind, model_name, model_version, content_hash);  -- Index for fast lookups by track CREATE INDEX IF NOT EXISTS track_embeddings_track_id_idx ON public.track_embeddings(track_id);  -- Vector index for similarity search (HNSW for better recall) CREATE INDEX IF NOT EXISTS track_embeddings_vector_idx ON public.track_embeddings USING hnsw (embedding vector_cosine_ops);  -- ============================================================================ -- 3. Create track_genres table -- ============================================================================ CREATE TABLE IF NOT EXISTS public.track_genres (     id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,     track_id INTEGER NOT NULL REFERENCES public.tracks(id) ON DELETE CASCADE,      -- Source identification     source TEXT NOT NULL,     source_level TEXT NOT NULL,      -- Content hash for invalidation     content_hash TEXT NOT NULL,      -- Genre data     genres TEXT[] NOT NULL DEFAULT '{}',     genres_with_scores JSONB,      -- Metadata     created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),     updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW() );  CREATE UNIQUE INDEX IF NOT EXISTS track_genres_unique_idx ON public.track_genres(track_id, source, content_hash);  CREATE INDEX IF NOT EXISTS track_genres_track_id_idx ON public.track_genres(track_id);  -- ============================================================================ -- 4. Create playlist_profiles table -- ============================================================================ CREATE TABLE IF NOT EXISTS public.playlist_profiles (     id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,     playlist_id INTEGER NOT NULL REFERENCES public.playlists(id) ON DELETE CASCADE,     user_id INTEGER NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,      -- Profile identification     profile_kind TEXT NOT NULL,     model_bundle_hash TEXT NOT NULL,     dims INTEGER NOT NULL,      -- Content hash for invalidation     content_hash TEXT NOT NULL,      -- Primary embedding vector (centroid of track embeddings)     embedding vector(1024),      -- Structured aggregates     audio_centroid JSONB,     genre_distribution JSONB,     emotion_distribution JSONB,      -- Source track info     track_count INTEGER NOT NULL DEFAULT 0,     track_ids INTEGER[] NOT NULL DEFAULT '{}',      -- Metadata     created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),     updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW() );  CREATE UNIQUE INDEX IF NOT EXISTS playlist_profiles_unique_idx ON public.playlist_profiles(playlist_id, profile_kind, model_bundle_hash, content_hash);  CREATE INDEX IF NOT EXISTS playlist_profiles_playlist_id_idx ON public.playlist_profiles(playlist_id);  CREATE INDEX IF NOT EXISTS playlist_profiles_user_id_idx ON public.playlist_profiles(user_id);  CREATE INDEX IF NOT EXISTS playlist_profiles_vector_idx ON public.playlist_profiles USING hnsw (embedding vector_cosine_ops) WHERE embedding IS NOT NULL;  -- ============================================================================ -- 5. Create match_contexts table -- ============================================================================ CREATE TABLE IF NOT EXISTS public.match_contexts (     id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,      -- User scope     user_id INTEGER NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,      -- Model bundle identifiers     embedding_model_name TEXT NOT NULL,     embedding_model_version TEXT NOT NULL,     reranker_model_name TEXT,     reranker_model_version TEXT,     emotion_model_name TEXT,     emotion_model_version TEXT,      -- Algorithm and config     algorithm_version TEXT NOT NULL,     config_hash TEXT NOT NULL,      -- Input set hashes (for invalidation)     playlist_set_hash TEXT NOT NULL,     candidate_set_hash TEXT NOT NULL,      -- Combined context hash for fast lookup     context_hash TEXT NOT NULL,      -- Metadata     created_at TIMESTAMPTZ NOT NULL DEFAULT NOW() );  CREATE UNIQUE INDEX IF NOT EXISTS match_contexts_hash_idx ON public.match_contexts(context_hash);  CREATE INDEX IF NOT EXISTS match_contexts_user_id_idx ON public.match_contexts(user_id);  -- ============================================================================ -- 6. Create match_results table -- ============================================================================ CREATE TABLE IF NOT EXISTS public.match_results (     id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,      -- Reference to the context     match_context_id BIGINT NOT NULL REFERENCES public.match_contexts(id) ON DELETE CASCADE,      -- The match itself     track_id INTEGER NOT NULL REFERENCES public.tracks(id) ON DELETE CASCADE,     playlist_id INTEGER NOT NULL REFERENCES public.playlists(id) ON DELETE CASCADE,      -- Score and breakdown     score NUMERIC(10, 6) NOT NULL,     factors JSONB NOT NULL,      -- Ranking within context     rank INTEGER,      -- Metadata     created_at TIMESTAMPTZ NOT NULL DEFAULT NOW() );  CREATE UNIQUE INDEX IF NOT EXISTS match_results_unique_idx ON public.match_results(match_context_id, track_id, playlist_id);  CREATE INDEX IF NOT EXISTS match_results_context_idx ON public.match_results(match_context_id);  CREATE INDEX IF NOT EXISTS match_results_playlist_idx ON public.match_results(match_context_id, playlist_id);  CREATE INDEX IF NOT EXISTS match_results_score_idx ON public.match_results(match_context_id, playlist_id, score DESC);  -- ============================================================================ -- 7. Add updated_at trigger function -- ============================================================================ CREATE OR REPLACE FUNCTION public.trigger_set_updated_at() RETURNS TRIGGER AS $$ BEGIN     NEW.updated_at = NOW();     RETURN NEW; END; $$ LANGUAGE plpgsql;  -- Apply triggers CREATE TRIGGER set_updated_at_track_embeddings     BEFORE UPDATE ON public.track_embeddings     FOR EACH ROW     EXECUTE FUNCTION public.trigger_set_updated_at();  CREATE TRIGGER set_updated_at_track_genres     BEFORE UPDATE ON public.track_genres     FOR EACH ROW     EXECUTE FUNCTION public.trigger_set_updated_at();  CREATE TRIGGER set_updated_at_playlist_profiles     BEFORE UPDATE ON public.playlist_profiles     FOR EACH ROW     EXECUTE FUNCTION public.trigger_set_updated_at();  -- ============================================================================ -- 8. Table comments for documentation -- ============================================================================ COMMENT ON TABLE public.track_embeddings IS 'Persisted track embeddings with versioning for model swaps.';  COMMENT ON TABLE public.track_genres IS 'Genre information from Last.fm with albumâ†’artist fallback.';  COMMENT ON TABLE public.playlist_profiles IS 'Computed playlist profiles with embedding centroid and aggregates.';  COMMENT ON TABLE public.match_contexts IS 'Context/configuration under which matches were computed.';  COMMENT ON TABLE public.match_results IS 'Individual match results keyed by match_context.';;
